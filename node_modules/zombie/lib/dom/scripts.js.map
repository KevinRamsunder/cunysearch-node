{"version":3,"sources":["dom/scripts.js"],"names":[],"mappings":";;;;AAEA,IAAM,GAAG,GAAe,OAAO,CAAC,SAAS,CAAC,CAAC;AAC3C,IAAM,cAAc,GAAI,OAAO,CAAC,yCAAyC,CAAC,CAAC;;;;;;AAO3E,GAAG,CAAC,kBAAkB,CAAC,UAAU,GAAG,UAAS,OAAO,EAAE,MAAM,EAAE,QAAQ,EAAE;AACtE,MAAM,IAAI,GAAG,MAAM,CAAC,QAAQ,EAAE,CAAC;;AAE/B,MAAI,CAAC,IAAI,EACP,OAAO;;;AAGT,MAAM,QAAQ,GAAG,OAAO,CAAC,aAAa,CAAC;AACvC,MAAM,MAAM,GAAK,QAAQ,CAAC,WAAW,CAAC;AACtC,MAAM,OAAO,GAAI,MAAM,CAAC,GAAG,CAAC,OAAO,CAAC;AACpC,MAAI,OAAO,IAAI,CAAC,OAAO,CAAC,UAAU,EAChC,OAAO;;;AAGT,MAAI;AACF,UAAM,CAAC,QAAQ,CAAC,cAAc,GAAG,OAAO,CAAC;AACzC,UAAM,CAAC,SAAS,CAAC,IAAI,EAAE,QAAQ,CAAC,CAAC;GAClC,CAAC,OAAO,KAAK,EAAE;AACd,QAAI,KAAK,CAAC,cAAc,CAAC,OAAO,CAAC,EAAE;AACjC,UAAM,IAAI,GAAG,IAAI,KAAK,CAAC,KAAK,CAAC,OAAO,IAAI,KAAK,CAAC,QAAQ,EAAE,CAAC,CAAC;AAC1D,UAAI,CAAC,KAAK,GAAG,KAAK,CAAC,KAAK,CAAC;AACzB,cAAQ,CAAC,KAAK,CAAC,OAAO,EAAE,KAAK,CAAC,OAAO,EAAE,EAAE,SAAS,EAAE,IAAI,EAAE,CAAC,CAAC;KAC7D,MACC,QAAQ,CAAC,KAAK,CAAC,OAAO,EAAE,KAAK,CAAC,OAAO,EAAE,EAAE,SAAS,EAAE,KAAK,EAAE,CAAC,CAAC;GAChE,SAAS;AACR,UAAM,CAAC,QAAQ,CAAC,cAAc,GAAG,IAAI,CAAC;GACvC;CACF,CAAC;;;;;;;;;AAUF,GAAG,CAAC,iBAAiB,CAAC,KAAK,GAAG,YAAW;AACvC,MAAI,CAAC,gBAAgB,CAAC,6BAA6B,EAAE,YAAW;AAC9D,QAAM,MAAM,GAAM,IAAI,CAAC;AACvB,QAAM,QAAQ,GAAI,MAAM,CAAC,aAAa,CAAC;;AAEvC,QAAI,MAAM,CAAC,GAAG;;AAEZ,oBAAc,CAAC,IAAI,CAAC,MAAM,EAAE,MAAM,CAAC,GAAG,EAAE,MAAM,CAAC,KAAK,CAAC,CAAC,KACnD;AACH,UAAM,QAAQ,GAAG,MAAM,CAAC,EAAE,GAAO,QAAQ,CAAC,GAAG,UAAK,MAAM,CAAC,EAAE,GAAQ,QAAQ,CAAC,GAAG,YAAS,CAAC;;AAEzF,UAAM,cAAc,GAAG,cAAc,CAAC,OAAO,CAAC,MAAM,EAAE,QAAQ,EAAE,mBAAmB,CAAC,CAAC;;;;;;;AAOrF,UAAI,QAAQ,CAAC,UAAU,KAAK,SAAS,EACnC,OAAO,CAAC,QAAQ,CAAC,cAAc,CAAC,CAAC,KAEjC,cAAc,EAAE,CAAC;KACpB;;;AAGD,aAAS,mBAAmB,CAAC,IAAI,EAAE,QAAQ,EAAE;AAC3C,YAAM,CAAC,KAAK,CAAC,MAAM,CAAC,WAAW,EAAE,QAAQ,CAAC,CAAC;KAC5C;GACF,CAAC,CAAC;CACJ,CAAC","file":"dom/scripts.js","sourcesContent":["// For handling JavaScript, mostly improvements to JSDOM\n\nconst DOM             = require('./index');\nconst resourceLoader  = require('jsdom/lib/jsdom/browser/resource-loader');\n\n\n// -- Patches to JSDOM --\n\n// If JSDOM encounters a JS error, it fires on the element.  We expect it to be\n// fires on the Window.  We also want better stack traces.\nDOM.languageProcessors.javascript = function(element, buffer, filename) {\n  const code = buffer.toString();\n  // This may be called without code, e.g. script element that has no body yet\n  if (!code)\n    return;\n\n  // Surpress JavaScript validation and execution\n  const document = element.ownerDocument;\n  const window   = document.defaultView;\n  const browser  = window.top.browser;\n  if (browser && !browser.runScripts)\n    return;\n\n  // This may be called without code, e.g. script element that has no body yet\n  try {\n    window.document._currentScript = element;\n    window._evaluate(code, filename);\n  } catch (error) {\n    if (error.hasOwnProperty('stack')) {\n      const cast = new Error(error.message || error.toString());\n      cast.stack = error.stack;\n      document.raise('error', error.message, { exception: cast });\n    } else\n      document.raise('error', error.message, { exception: error });\n  } finally {\n    window.document._currentScript = null;\n  }\n};\n\n\n// HTML5 parser doesn't play well with JSDOM so we need this trickey to sort of\n// get script execution to work properly.\n//\n// Basically JSDOM listend for when the script tag is added to the DOM and\n// attemps to evaluate at, but the script has no contents at that point in\n// time.  This adds just enough delay for the inline script's content to be\n// parsed and ready for processing.\nDOM.HTMLScriptElement._init = function() {\n  this.addEventListener('DOMNodeInsertedIntoDocument', function() {\n    const script    = this;\n    const document  = script.ownerDocument;\n\n    if (script.src)\n      // Script has a src attribute, load external resource.\n      resourceLoader.load(script, script.src, script._eval);\n    else {\n      const filename = script.id ?  `${document.URL}:#${script.id}` : `${document.URL}:script`;\n      // Queue to be executed in order with all other scripts\n      const executeInOrder = resourceLoader.enqueue(script, filename, executeInlineScript);\n      // There are two scenarios:\n      // - script element added to existing document, we should evaluate it\n      //   immediately\n      // - inline script element parsed, when we get here, we still don't have\n      //   the element contents, so we have to wait before we can read and\n      //   execute it\n      if (document.readyState === 'loading')\n        process.nextTick(executeInOrder);\n      else\n        executeInOrder();\n    }\n\n    // Execute inline script\n    function executeInlineScript(code, filename) {\n      script._eval(script.textContent, filename);\n    }\n  });\n};\n\n"],"sourceRoot":"/source/"}